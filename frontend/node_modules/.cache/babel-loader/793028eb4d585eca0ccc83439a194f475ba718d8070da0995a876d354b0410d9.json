{"ast":null,"code":"import * as React from 'react';\nimport useEventCallback from '@mui/utils/useEventCallback';\nimport { usePickerAdapter, usePickerTranslations } from \"../../../hooks/index.js\";\nimport { syncSelectionToDOM } from \"./syncSelectionToDOM.js\";\n/**\n * Generate the props to pass to the content element of each section of the field.\n * It is not used by the non-accessible DOM structure (with an <input /> element for editing).\n * It should be used in the MUI accessible DOM structure and the Base UI implementation.\n * @param {UseFieldRootPropsParameters} parameters The parameters of the hook.\n * @returns {UseFieldRootPropsReturnValue} The props to forward to the content element of each section of the field.\n */\nexport function useFieldSectionContentProps(parameters) {\n  const adapter = usePickerAdapter();\n  const translations = usePickerTranslations();\n  const {\n    focused,\n    domGetters,\n    stateResponse,\n    applyCharacterEditing,\n    manager: {\n      internal_fieldValueManager: fieldValueManager\n    },\n    stateResponse: {\n      // States and derived states\n      parsedSelectedSections,\n      sectionsValueBoundaries,\n      state,\n      value,\n      // Methods to update the states\n      clearActiveSection,\n      setCharacterQuery,\n      setSelectedSections,\n      updateSectionValue,\n      updateValueFromValueStr\n    },\n    internalPropsWithDefaults: {\n      disabled = false,\n      readOnly = false\n    }\n  } = parameters;\n  const isContainerEditable = parsedSelectedSections === 'all';\n  const isEditable = !isContainerEditable && !disabled && !readOnly;\n\n  /**\n   * If a section content has been updated with a value we don't want to keep,\n   * Then we need to imperatively revert it (we can't let React do it because the value did not change in his internal representation).\n   */\n  const revertDOMSectionChange = useEventCallback(sectionIndex => {\n    if (!domGetters.isReady()) {\n      return;\n    }\n    const section = state.sections[sectionIndex];\n    domGetters.getSectionContent(sectionIndex).innerHTML = section.value || section.placeholder;\n    syncSelectionToDOM({\n      focused,\n      domGetters,\n      stateResponse\n    });\n  });\n  const handleInput = useEventCallback(event => {\n    if (!domGetters.isReady()) {\n      return;\n    }\n    const target = event.target;\n    const keyPressed = target.textContent ?? '';\n    const sectionIndex = domGetters.getSectionIndexFromDOMElement(target);\n    const section = state.sections[sectionIndex];\n    if (readOnly) {\n      revertDOMSectionChange(sectionIndex);\n      return;\n    }\n    if (keyPressed.length === 0) {\n      if (section.value === '') {\n        revertDOMSectionChange(sectionIndex);\n        return;\n      }\n      const inputType = event.nativeEvent.inputType;\n      if (inputType === 'insertParagraph' || inputType === 'insertLineBreak') {\n        revertDOMSectionChange(sectionIndex);\n        return;\n      }\n      revertDOMSectionChange(sectionIndex);\n      clearActiveSection();\n      return;\n    }\n    applyCharacterEditing({\n      keyPressed,\n      sectionIndex\n    });\n\n    // The DOM value needs to remain the one React is expecting.\n    revertDOMSectionChange(sectionIndex);\n  });\n  const handleMouseUp = useEventCallback(event => {\n    // Without this, the browser will remove the selected when clicking inside an already-selected section.\n    event.preventDefault();\n  });\n  const handlePaste = useEventCallback(event => {\n    // prevent default to avoid the input `onInput` handler being called\n    event.preventDefault();\n    if (readOnly || disabled || typeof parsedSelectedSections !== 'number') {\n      return;\n    }\n    const activeSection = state.sections[parsedSelectedSections];\n    const pastedValue = event.clipboardData.getData('text');\n    const lettersOnly = /^[a-zA-Z]+$/.test(pastedValue);\n    const digitsOnly = /^[0-9]+$/.test(pastedValue);\n    const digitsAndLetterOnly = /^(([a-zA-Z]+)|)([0-9]+)(([a-zA-Z]+)|)$/.test(pastedValue);\n    const isValidPastedValue = activeSection.contentType === 'letter' && lettersOnly || activeSection.contentType === 'digit' && digitsOnly || activeSection.contentType === 'digit-with-letter' && digitsAndLetterOnly;\n    if (isValidPastedValue) {\n      setCharacterQuery(null);\n      updateSectionValue({\n        section: activeSection,\n        newSectionValue: pastedValue,\n        shouldGoToNextSection: true\n      });\n    }\n    // If the pasted value corresponds to a single section, but not the expected type, we skip the modification\n    else if (!lettersOnly && !digitsOnly) {\n      setCharacterQuery(null);\n      updateValueFromValueStr(pastedValue);\n    }\n  });\n  const handleDragOver = useEventCallback(event => {\n    event.preventDefault();\n    event.dataTransfer.dropEffect = 'none';\n  });\n  const createFocusHandler = React.useCallback(sectionIndex => () => {\n    if (disabled) {\n      return;\n    }\n    setSelectedSections(sectionIndex);\n  }, [disabled, setSelectedSections]);\n  return React.useCallback((section, sectionIndex) => {\n    const sectionBoundaries = sectionsValueBoundaries[section.type]({\n      currentDate: fieldValueManager.getDateFromSection(value, section),\n      contentType: section.contentType,\n      format: section.format\n    });\n    return {\n      // Event handlers\n      onInput: handleInput,\n      onPaste: handlePaste,\n      onMouseUp: handleMouseUp,\n      onDragOver: handleDragOver,\n      onFocus: createFocusHandler(sectionIndex),\n      // Aria attributes\n      'aria-readonly': readOnly,\n      'aria-valuenow': getSectionValueNow(section, adapter),\n      'aria-valuemin': sectionBoundaries.minimum,\n      'aria-valuemax': sectionBoundaries.maximum,\n      'aria-valuetext': section.value ? getSectionValueText(section, adapter) : translations.empty,\n      'aria-label': translations[section.type],\n      'aria-disabled': disabled,\n      // Other\n      tabIndex: isContainerEditable || sectionIndex > 0 ? -1 : 0,\n      contentEditable: !isContainerEditable && !disabled && !readOnly,\n      role: 'spinbutton',\n      'data-range-position': section.dateName || undefined,\n      spellCheck: isEditable ? false : undefined,\n      autoCapitalize: isEditable ? 'off' : undefined,\n      autoCorrect: isEditable ? 'off' : undefined,\n      children: section.value || section.placeholder,\n      inputMode: section.contentType === 'letter' ? 'text' : 'numeric'\n    };\n  }, [sectionsValueBoundaries, isContainerEditable, disabled, readOnly, isEditable, translations, adapter, handleInput, handlePaste, handleMouseUp, handleDragOver, createFocusHandler, fieldValueManager, value]);\n}\nfunction getSectionValueText(section, adapter) {\n  if (!section.value) {\n    return undefined;\n  }\n  switch (section.type) {\n    case 'month':\n      {\n        if (section.contentType === 'digit') {\n          const dateWithMonth = adapter.setMonth(adapter.date(), Number(section.value) - 1);\n          return adapter.isValid(dateWithMonth) ? adapter.format(dateWithMonth, 'month') : '';\n        }\n        const parsedDate = adapter.parse(section.value, section.format);\n        return parsedDate && adapter.isValid(parsedDate) ? adapter.format(parsedDate, 'month') : undefined;\n      }\n    case 'day':\n      if (section.contentType === 'digit') {\n        const dateWithDay = adapter.setDate(adapter.startOfYear(adapter.date()), Number(section.value));\n        return adapter.isValid(dateWithDay) ? adapter.format(dateWithDay, 'dayOfMonthFull') : '';\n      }\n      return section.value;\n    case 'weekDay':\n      // TODO: improve by providing the label of the week day\n      return undefined;\n    default:\n      return undefined;\n  }\n}\nfunction getSectionValueNow(section, adapter) {\n  if (!section.value) {\n    return undefined;\n  }\n  switch (section.type) {\n    case 'weekDay':\n      {\n        if (section.contentType === 'letter') {\n          // TODO: improve by resolving the week day number from a letter week day\n          return undefined;\n        }\n        return Number(section.value);\n      }\n    case 'meridiem':\n      {\n        const parsedDate = adapter.parse(`01:00 ${section.value}`, `${adapter.formats.hours12h}:${adapter.formats.minutes} ${section.format}`);\n        if (parsedDate) {\n          return adapter.getHours(parsedDate) >= 12 ? 1 : 0;\n        }\n        return undefined;\n      }\n    case 'day':\n      return section.contentType === 'digit-with-letter' ? parseInt(section.value, 10) : Number(section.value);\n    case 'month':\n      {\n        if (section.contentType === 'digit') {\n          return Number(section.value);\n        }\n        const parsedDate = adapter.parse(section.value, section.format);\n        return parsedDate ? adapter.getMonth(parsedDate) + 1 : undefined;\n      }\n    default:\n      return section.contentType !== 'letter' ? Number(section.value) : undefined;\n  }\n}","map":{"version":3,"names":["React","useEventCallback","usePickerAdapter","usePickerTranslations","syncSelectionToDOM","useFieldSectionContentProps","parameters","adapter","translations","focused","domGetters","stateResponse","applyCharacterEditing","manager","internal_fieldValueManager","fieldValueManager","parsedSelectedSections","sectionsValueBoundaries","state","value","clearActiveSection","setCharacterQuery","setSelectedSections","updateSectionValue","updateValueFromValueStr","internalPropsWithDefaults","disabled","readOnly","isContainerEditable","isEditable","revertDOMSectionChange","sectionIndex","isReady","section","sections","getSectionContent","innerHTML","placeholder","handleInput","event","target","keyPressed","textContent","getSectionIndexFromDOMElement","length","inputType","nativeEvent","handleMouseUp","preventDefault","handlePaste","activeSection","pastedValue","clipboardData","getData","lettersOnly","test","digitsOnly","digitsAndLetterOnly","isValidPastedValue","contentType","newSectionValue","shouldGoToNextSection","handleDragOver","dataTransfer","dropEffect","createFocusHandler","useCallback","sectionBoundaries","type","currentDate","getDateFromSection","format","onInput","onPaste","onMouseUp","onDragOver","onFocus","getSectionValueNow","minimum","maximum","getSectionValueText","empty","tabIndex","contentEditable","role","dateName","undefined","spellCheck","autoCapitalize","autoCorrect","children","inputMode","dateWithMonth","setMonth","date","Number","isValid","parsedDate","parse","dateWithDay","setDate","startOfYear","formats","hours12h","minutes","getHours","parseInt","getMonth"],"sources":["/Users/ankushgupta/Documents/my_project/vendor_management/frontend/node_modules/@mui/x-date-pickers/esm/internals/hooks/useField/useFieldSectionContentProps.js"],"sourcesContent":["import * as React from 'react';\nimport useEventCallback from '@mui/utils/useEventCallback';\nimport { usePickerAdapter, usePickerTranslations } from \"../../../hooks/index.js\";\nimport { syncSelectionToDOM } from \"./syncSelectionToDOM.js\";\n/**\n * Generate the props to pass to the content element of each section of the field.\n * It is not used by the non-accessible DOM structure (with an <input /> element for editing).\n * It should be used in the MUI accessible DOM structure and the Base UI implementation.\n * @param {UseFieldRootPropsParameters} parameters The parameters of the hook.\n * @returns {UseFieldRootPropsReturnValue} The props to forward to the content element of each section of the field.\n */\nexport function useFieldSectionContentProps(parameters) {\n  const adapter = usePickerAdapter();\n  const translations = usePickerTranslations();\n  const {\n    focused,\n    domGetters,\n    stateResponse,\n    applyCharacterEditing,\n    manager: {\n      internal_fieldValueManager: fieldValueManager\n    },\n    stateResponse: {\n      // States and derived states\n      parsedSelectedSections,\n      sectionsValueBoundaries,\n      state,\n      value,\n      // Methods to update the states\n      clearActiveSection,\n      setCharacterQuery,\n      setSelectedSections,\n      updateSectionValue,\n      updateValueFromValueStr\n    },\n    internalPropsWithDefaults: {\n      disabled = false,\n      readOnly = false\n    }\n  } = parameters;\n  const isContainerEditable = parsedSelectedSections === 'all';\n  const isEditable = !isContainerEditable && !disabled && !readOnly;\n\n  /**\n   * If a section content has been updated with a value we don't want to keep,\n   * Then we need to imperatively revert it (we can't let React do it because the value did not change in his internal representation).\n   */\n  const revertDOMSectionChange = useEventCallback(sectionIndex => {\n    if (!domGetters.isReady()) {\n      return;\n    }\n    const section = state.sections[sectionIndex];\n    domGetters.getSectionContent(sectionIndex).innerHTML = section.value || section.placeholder;\n    syncSelectionToDOM({\n      focused,\n      domGetters,\n      stateResponse\n    });\n  });\n  const handleInput = useEventCallback(event => {\n    if (!domGetters.isReady()) {\n      return;\n    }\n    const target = event.target;\n    const keyPressed = target.textContent ?? '';\n    const sectionIndex = domGetters.getSectionIndexFromDOMElement(target);\n    const section = state.sections[sectionIndex];\n    if (readOnly) {\n      revertDOMSectionChange(sectionIndex);\n      return;\n    }\n    if (keyPressed.length === 0) {\n      if (section.value === '') {\n        revertDOMSectionChange(sectionIndex);\n        return;\n      }\n      const inputType = event.nativeEvent.inputType;\n      if (inputType === 'insertParagraph' || inputType === 'insertLineBreak') {\n        revertDOMSectionChange(sectionIndex);\n        return;\n      }\n      revertDOMSectionChange(sectionIndex);\n      clearActiveSection();\n      return;\n    }\n    applyCharacterEditing({\n      keyPressed,\n      sectionIndex\n    });\n\n    // The DOM value needs to remain the one React is expecting.\n    revertDOMSectionChange(sectionIndex);\n  });\n  const handleMouseUp = useEventCallback(event => {\n    // Without this, the browser will remove the selected when clicking inside an already-selected section.\n    event.preventDefault();\n  });\n  const handlePaste = useEventCallback(event => {\n    // prevent default to avoid the input `onInput` handler being called\n    event.preventDefault();\n    if (readOnly || disabled || typeof parsedSelectedSections !== 'number') {\n      return;\n    }\n    const activeSection = state.sections[parsedSelectedSections];\n    const pastedValue = event.clipboardData.getData('text');\n    const lettersOnly = /^[a-zA-Z]+$/.test(pastedValue);\n    const digitsOnly = /^[0-9]+$/.test(pastedValue);\n    const digitsAndLetterOnly = /^(([a-zA-Z]+)|)([0-9]+)(([a-zA-Z]+)|)$/.test(pastedValue);\n    const isValidPastedValue = activeSection.contentType === 'letter' && lettersOnly || activeSection.contentType === 'digit' && digitsOnly || activeSection.contentType === 'digit-with-letter' && digitsAndLetterOnly;\n    if (isValidPastedValue) {\n      setCharacterQuery(null);\n      updateSectionValue({\n        section: activeSection,\n        newSectionValue: pastedValue,\n        shouldGoToNextSection: true\n      });\n    }\n    // If the pasted value corresponds to a single section, but not the expected type, we skip the modification\n    else if (!lettersOnly && !digitsOnly) {\n      setCharacterQuery(null);\n      updateValueFromValueStr(pastedValue);\n    }\n  });\n  const handleDragOver = useEventCallback(event => {\n    event.preventDefault();\n    event.dataTransfer.dropEffect = 'none';\n  });\n  const createFocusHandler = React.useCallback(sectionIndex => () => {\n    if (disabled) {\n      return;\n    }\n    setSelectedSections(sectionIndex);\n  }, [disabled, setSelectedSections]);\n  return React.useCallback((section, sectionIndex) => {\n    const sectionBoundaries = sectionsValueBoundaries[section.type]({\n      currentDate: fieldValueManager.getDateFromSection(value, section),\n      contentType: section.contentType,\n      format: section.format\n    });\n    return {\n      // Event handlers\n      onInput: handleInput,\n      onPaste: handlePaste,\n      onMouseUp: handleMouseUp,\n      onDragOver: handleDragOver,\n      onFocus: createFocusHandler(sectionIndex),\n      // Aria attributes\n      'aria-readonly': readOnly,\n      'aria-valuenow': getSectionValueNow(section, adapter),\n      'aria-valuemin': sectionBoundaries.minimum,\n      'aria-valuemax': sectionBoundaries.maximum,\n      'aria-valuetext': section.value ? getSectionValueText(section, adapter) : translations.empty,\n      'aria-label': translations[section.type],\n      'aria-disabled': disabled,\n      // Other\n      tabIndex: isContainerEditable || sectionIndex > 0 ? -1 : 0,\n      contentEditable: !isContainerEditable && !disabled && !readOnly,\n      role: 'spinbutton',\n      'data-range-position': section.dateName || undefined,\n      spellCheck: isEditable ? false : undefined,\n      autoCapitalize: isEditable ? 'off' : undefined,\n      autoCorrect: isEditable ? 'off' : undefined,\n      children: section.value || section.placeholder,\n      inputMode: section.contentType === 'letter' ? 'text' : 'numeric'\n    };\n  }, [sectionsValueBoundaries, isContainerEditable, disabled, readOnly, isEditable, translations, adapter, handleInput, handlePaste, handleMouseUp, handleDragOver, createFocusHandler, fieldValueManager, value]);\n}\nfunction getSectionValueText(section, adapter) {\n  if (!section.value) {\n    return undefined;\n  }\n  switch (section.type) {\n    case 'month':\n      {\n        if (section.contentType === 'digit') {\n          const dateWithMonth = adapter.setMonth(adapter.date(), Number(section.value) - 1);\n          return adapter.isValid(dateWithMonth) ? adapter.format(dateWithMonth, 'month') : '';\n        }\n        const parsedDate = adapter.parse(section.value, section.format);\n        return parsedDate && adapter.isValid(parsedDate) ? adapter.format(parsedDate, 'month') : undefined;\n      }\n    case 'day':\n      if (section.contentType === 'digit') {\n        const dateWithDay = adapter.setDate(adapter.startOfYear(adapter.date()), Number(section.value));\n        return adapter.isValid(dateWithDay) ? adapter.format(dateWithDay, 'dayOfMonthFull') : '';\n      }\n      return section.value;\n    case 'weekDay':\n      // TODO: improve by providing the label of the week day\n      return undefined;\n    default:\n      return undefined;\n  }\n}\nfunction getSectionValueNow(section, adapter) {\n  if (!section.value) {\n    return undefined;\n  }\n  switch (section.type) {\n    case 'weekDay':\n      {\n        if (section.contentType === 'letter') {\n          // TODO: improve by resolving the week day number from a letter week day\n          return undefined;\n        }\n        return Number(section.value);\n      }\n    case 'meridiem':\n      {\n        const parsedDate = adapter.parse(`01:00 ${section.value}`, `${adapter.formats.hours12h}:${adapter.formats.minutes} ${section.format}`);\n        if (parsedDate) {\n          return adapter.getHours(parsedDate) >= 12 ? 1 : 0;\n        }\n        return undefined;\n      }\n    case 'day':\n      return section.contentType === 'digit-with-letter' ? parseInt(section.value, 10) : Number(section.value);\n    case 'month':\n      {\n        if (section.contentType === 'digit') {\n          return Number(section.value);\n        }\n        const parsedDate = adapter.parse(section.value, section.format);\n        return parsedDate ? adapter.getMonth(parsedDate) + 1 : undefined;\n      }\n    default:\n      return section.contentType !== 'letter' ? Number(section.value) : undefined;\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}